---
id: manipulation
title: "6. Principles of Robotic Manipulation"
description: "The fundamentals of how humanoid robots can grasp and manipulate objects."
sidebar_position: 6
---

import Mermaid from '@theme/Mermaid';
import CodeBlock from '@theme/CodeBlock';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## The Art of Interaction

Locomotion gets a robot to the right place, but **manipulation** allows it to perform useful tasks once it's there. Manipulation is the art and science of physically interacting with objects: picking them up, moving them, and using them to achieve a goal. For a humanoid robot, this means controlling its arms and hands with precision and dexterity.

This chapter explores the core principles that govern how a robot controls its limbs to interact with the world.

### The Arm: A Kinematic Chain

A robot's arm is a **kinematic chain**: a sequence of rigid links (the bones) connected by joints (like your elbow and shoulder). To control the arm, we must understand its geometry. This is the study of kinematics.

<Mermaid chart={`
graph TD
    A(Base) -- Link 1 --> B(Joint 1);
    B -- Link 2 --> C(Joint 2);
    C -- Link 3 --> D(End-Effector / Hand);

    style A fill:#f9f9f9,stroke:#333,stroke-width:2px
    style D fill:#bde0fe,stroke:#333,stroke-width:2px
`} />

#### Forward Kinematics (FK): The "Easy" Question
*   **Question:** If I know the angles of all my joints, where is my hand?
*   **Process:** FK uses the robot's known link lengths and its measured joint angles (from encoders) to calculate the precise 3D position and orientation of the end-effector. It's a straightforward problem of applying a series of geometric transformations (translations and rotations).

#### Inverse Kinematics (IK): The "Hard" Question
*   **Question:** If I want my hand to be at a specific target position, what should all my joint angles be?
*   **Process:** This is a much harder problem. Unlike FK, which has one unique answer, IK can have:
    *   **No solution:** The target is outside the robot's reachable workspace.
    *   **Multiple solutions:** The robot can reach the same point with different poses (e.g., "elbow up" vs. "elbow down").
    *   **Infinite solutions:** If the robot is *redundant* (has more joints than necessary), there are infinite ways to reach a target.

IK is typically solved with iterative numerical optimizers that try to find the best joint configuration to minimize the distance between the hand and the target.

### The Hand: End-Effectors
The "hand" of the robot is its end-effector.
-   **Simple Grippers:** Most robots today use simple two-fingered parallel grippers. They are robust, simple to control, and effective for a wide range of objects.
-   **Dextrous Hands:** Advanced, multi-fingered hands that mimic human dexterity are a major area of research. They offer incredible flexibility but are mechanically complex and extremely difficult to control.

A key distinction in grasping is the difference between a **power grasp** (wrapping the whole hand around an object for a secure hold) and a **precision grasp** (using the fingertips for fine-grained control).

### From Position to Force: The Jacobian

So far, we've only talked about position. But manipulation is fundamentally about applying **forces**. How do we control the force exerted by the hand? The answer lies in a critical piece of mathematics: the **Jacobian matrix (J)**.

The Jacobian is the bridge between the robot's joints and its end-effector.
1.  **Velocity Mapping:** It relates the velocity of the joints to the velocity of the hand.
    `end_effector_velocity = J * joint_velocities`
2.  **Force Mapping:** Through its transpose (`J^T`), it also relates the force you want to apply with the hand to the torques you need at the joints.
    `joint_torques = J^T * end_effector_force`

The Jacobian allows us to switch from thinking purely in terms of position to thinking in terms of force.

### The Importance of Feeling: Force Control and Compliance

Imagine trying to open a drawer with your eyes closed. You would push forward gently until you felt the handle, then pull. You are using force feedback. A robot must do the same.

A purely position-controlled robot is a poor manipulator. If it's commanded to move to a point inside a table, it will try to do so with maximum force, potentially breaking itself or the table. To perform contact tasks, a robot needs **compliance**.

**Compliance** is the ability to yield or "be soft" in response to external forces. It is essential for:
-   **Safety:** A compliant robot is safer to be around.
-   **Contact Tasks:** Inserting a key, wiping a surface, or turning a crank all require compliant control that balances position and force.

**Hybrid Position/Force Control** is a common strategy where the robot's control is split. For example, when sliding a block along a table, the controller might be in "position control" in the horizontal direction but in "force control" in the vertical direction, commanding the arm to always press down with a gentle, constant force.

### Code Example: Forward Kinematics for a 2-Link Arm

Let's see how Forward Kinematics works with a simple 2D, two-link robot arm. Given the link lengths and joint angles, we can calculate the position of the hand.

<Tabs>
<TabItem value="python" label="Python">
<CodeBlock language="python">
{`import numpy as np

def forward_kinematics_2d(link_lengths, joint_angles):
    """
    Calculates the (x, y) position of a 2D, 2-link robot arm's end-effector.

    Args:
        link_lengths (list or tuple): A list of two link lengths [l1, l2].
        joint_angles (list or tuple): A list of two joint angles in radians [theta1, theta2].
                                     theta1 is the angle of the first link from the base.
                                     theta2 is the angle of the second link relative to the first.
    
    Returns:
        np.array: A 2D array [x, y] for the end-effector's position.
    """
    l1, l2 = link_lengths
    th1, th2 = joint_angles
    
    # Position of the end of the first link (the "elbow")
    x1 = l1 * np.cos(th1)
    y1 = l1 * np.sin(th1)
    
    # The angle of the second link is relative to the first, so we add the angles.
    # The position of the end-effector is relative to the elbow.
    x2 = x1 + l2 * np.cos(th1 + th2)
    y2 = y1 + l2 * np.sin(th1 + th2)
    
    return np.array([x2, y2])

# --- Simulation ---
link_lengths = [1.0, 0.8] # Link 1 is 1.0m, Link 2 is 0.8m

# Case 1: Both joints at 90 degrees (pointing straight up)
angles1 = [np.pi / 2, 0] # 90 degrees for th1, 0 for th2
pos1 = forward_kinematics_2d(link_lengths, angles1)
print(f"Angles {np.rad2deg(angles1)} deg -> End-effector position: {pos1.round(2)}")

# Case 2: First joint at 45 degrees, second bent inward by 90 degrees
angles2 = [np.pi / 4, -np.pi / 2] # 45 degrees for th1, -90 for th2
pos2 = forward_kinematics_2d(link_lengths, angles2)
print(f"Angles {np.rad2deg(angles2)} deg -> End-effector position: {pos2.round(2)}")
`}
</CodeBlock>
</TabItem>
</Tabs>