"use strict";(globalThis.webpackChunkhumanoid_robotics_textbook=globalThis.webpackChunkhumanoid_robotics_textbook||[]).push([[115],{7499:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>f,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"hardware-software-codesign","title":"11. Hardware-Software Co-Design","description":"The interplay between hardware design and software development.","source":"@site/docs/11-hardware-software-codesign.mdx","sourceDirName":".","slug":"/hardware-software-codesign","permalink":"/humanoid_robotics_textbook/hardware-software-codesign","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":11,"frontMatter":{"id":"hardware-software-codesign","title":"11. Hardware-Software Co-Design","description":"The interplay between hardware design and software development.","sidebar_position":11},"sidebar":"tutorialSidebar","previous":{"title":"10. Simulation & Sim-to-Real","permalink":"/humanoid_robotics_textbook/simulation-sim-to-real"},"next":{"title":"12. Safety and Failure Analysis","permalink":"/humanoid_robotics_textbook/safety-failure-analysis"}}');var n=o(4848),r=o(8453),s=o(418);const a={id:"hardware-software-codesign",title:"11. Hardware-Software Co-Design",description:"The interplay between hardware design and software development.",sidebar_position:11},l=void 0,c={},d=[{value:"A Symbiotic Relationship",id:"a-symbiotic-relationship",level:2},{value:"The Myth of &quot;Software Will Fix It&quot;",id:"the-myth-of-software-will-fix-it",level:3},{value:"Co-Design in Action: Trade-Offs and Decisions",id:"co-design-in-action-trade-offs-and-decisions",level:3},{value:"Actuator Design: Enabling Force Control",id:"actuator-design-enabling-force-control",level:4},{value:"Sensor Suite: The Quality of Perception",id:"sensor-suite-the-quality-of-perception",level:4},{value:"Onboard Compute: The Brain of the Robot",id:"onboard-compute-the-brain-of-the-robot",level:4},{value:"The Virtuous Cycle",id:"the-virtuous-cycle",level:3}];function h(e){const t={em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h2,{id:"a-symbiotic-relationship",children:"A Symbiotic Relationship"}),"\n",(0,n.jsx)(t.p,{children:'A common misconception in engineering is that a project follows a clean, sequential path: first, the hardware team builds the machine, then they "throw it over the wall" to the software team to make it work. In humanoid robotics, this approach is doomed to fail.'}),"\n",(0,n.jsxs)(t.p,{children:["Building a capable robot is not a hardware problem or a software problem; it's a ",(0,n.jsx)(t.strong,{children:"systems"})," problem. The most successful robotics companies operate on a principle of deep and continuous ",(0,n.jsx)(t.strong,{children:"hardware-software co-design"}),". The capabilities of the software are fundamentally constrained by the quality of the hardware, and the design of the hardware should be motivated by the needs of the software."]}),"\n",(0,n.jsx)(t.p,{children:"This chapter explores this critical, symbiotic relationship."}),"\n",(0,n.jsx)(t.h3,{id:"the-myth-of-software-will-fix-it",children:'The Myth of "Software Will Fix It"'}),"\n",(0,n.jsx)(t.p,{children:'No amount of clever code can overcome the limitations of poorly designed hardware. A software engineer cannot program a robot to be "gentle" if its motors are stiff and powerful with no ability to sense force. A perception algorithm cannot reliably detect objects if the robot\'s cameras are low-quality and mounted with a poor field of view.'}),"\n",(0,n.jsx)(t.p,{children:"Effective co-design is a tight feedback loop where decisions in one domain directly influence and enable decisions in the other."}),"\n",(0,n.jsx)(s.A,{chart:'\ngraph TD\n  A(Hardware Design) --"Defines Possibilities"--\x3e B(Software Architecture);\n  B --"Reveals Limitations"--\x3e C(System Performance);\n  C --"Drives Requirements"--\x3e D(Hardware Redesign / Needs);\n  D --"Informs Next Iteration"--\x3e A;\n'}),"\n",(0,n.jsx)(t.h3,{id:"co-design-in-action-trade-offs-and-decisions",children:"Co-Design in Action: Trade-Offs and Decisions"}),"\n",(0,n.jsx)(t.p,{children:"Let's look at concrete examples of how hardware and software choices are intertwined, drawing on concepts from previous chapters."}),"\n",(0,n.jsx)(t.h4,{id:"actuator-design-enabling-force-control",children:"Actuator Design: Enabling Force Control"}),"\n",(0,n.jsx)(t.p,{children:"As we saw in Chapter 6, the ability to control force is critical for safe and effective manipulation. This is a classic co-design problem."}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Hardware Choice"}),(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Software it Enables"}),(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Software it Constrains"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.strong,{children:"High-Torque, Low-Gear-Ratio Actuators"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.strong,{children:"Rich Force Control & Compliance."}),' Because there is little friction between the motor and the joint, software can "feel" external forces and react to them. This allows for soft, compliant behavior.']}),(0,n.jsx)(t.td,{style:{textAlign:"left"},children:"Complex control algorithms are required to manage the dynamics. Not ideal for holding a stiff position under load."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.strong,{children:"Low-Cost, High-Gear-Ratio Actuators"})}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.strong,{children:"Simple, Stiff Position Control."})," These are excellent at moving to a specific position and holding it rigidly. The software can be much simpler."]}),(0,n.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,n.jsx)(t.strong,{children:"No True Force Control."}),' The high gear ratio adds too much friction, making it impossible for the software to sense subtle external forces. The robot is "numb" to its environment.']})]})]})]}),"\n",(0,n.jsxs)(t.p,{children:["A team that wants to build a robot capable of delicate assembly tasks ",(0,n.jsx)(t.em,{children:"must"})," choose the more advanced actuator. The software problem is unsolvable otherwise."]}),"\n",(0,n.jsx)(t.h4,{id:"sensor-suite-the-quality-of-perception",children:"Sensor Suite: The Quality of Perception"}),"\n",(0,n.jsx)(t.p,{children:"The software's ability to model the world (Chapter 4) and perceive its surroundings (Chapter 3) is directly tied to the sensors it receives data from."}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Adding Force-Torque Sensors:"})," Placing F/T sensors in the robot's wrists and ankles is a hardware decision. It provides the software with a clean, direct measurement of contact forces. This dramatically improves the performance of balance algorithms (Chapter 5) and manipulation controllers (Chapter 6). Without them, software must ",(0,n.jsx)(t.em,{children:"estimate"})," forces from noisy motor current data, which is far less reliable."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Choosing a Camera:"})," Opting for a high-resolution, high-framerate camera with a global shutter (a hardware choice) reduces motion blur and provides richer data to the perception stack. This enables the software to run more accurate and reliable object detection and tracking algorithms."]}),"\n"]}),"\n",(0,n.jsx)(t.h4,{id:"onboard-compute-the-brain-of-the-robot",children:"Onboard Compute: The Brain of the Robot"}),"\n",(0,n.jsx)(t.p,{children:"The choice of onboard computer dictates the entire software architecture, especially for modern, AI-driven robots."}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Including a Powerful GPU:"})," This hardware choice is a prerequisite for running the large neural networks that define modern robotics. It enables the software team to implement:","\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Complex computer vision models for semantic segmentation."}),"\n",(0,n.jsx)(t.li,{children:"VLM-based scene understanding (Chapter 9)."}),"\n",(0,n.jsx)(t.li,{children:"Potentially even running parts of an LLM planner locally on the robot."}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Using only a CPU:"}),' Without a GPU, the software team is constrained to "classical" robotics algorithms. This may be sufficient for a factory robot performing a repetitive task, but it makes it nearly impossible to build a general-purpose, AI-driven humanoid.']}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"the-virtuous-cycle",children:"The Virtuous Cycle"}),"\n",(0,n.jsx)(t.p,{children:"The ideal robotics development process is a virtuous cycle:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"Hardware engineers create a prototype with the best possible sensors and actuators."}),"\n",(0,n.jsx)(t.li,{children:"Software engineers use this high-quality data and control to build more advanced and robust perception and control algorithms."}),"\n",(0,n.jsx)(t.li,{children:'The performance of this advanced software reveals the next hardware bottleneck (e.g., "We could balance better if we had a faster IMU").'}),"\n",(0,n.jsx)(t.li,{children:"This feedback informs the design of the next hardware revision."}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"This tight integration is why progress in robotics can seem slow from the outside but is often a story of intense, iterative, and deeply collaborative engineering."})]})}function f(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},8453:(e,t,o)=>{o.d(t,{R:()=>s,x:()=>a});var i=o(6540);const n={},r=i.createContext(n);function s(e){const t=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);