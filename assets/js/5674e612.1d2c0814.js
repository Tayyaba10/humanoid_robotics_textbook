"use strict";(globalThis.webpackChunkhumanoid_robotics_textbook=globalThis.webpackChunkhumanoid_robotics_textbook||[]).push([[863],{1470:(e,n,t)=>{t.d(n,{A:()=>k});var o=t(6540),r=t(4164),i=t(7559),s=t(3104),a=t(6347),l=t(205),c=t(7485),h=t(1682),d=t(679);function u(e){return o.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,o.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function p(e){const{values:n,children:t}=e;return(0,o.useMemo)(()=>{const e=n??function(e){return u(e).map(({props:{value:e,label:n,attributes:t,default:o}})=>({value:e,label:n,attributes:t,default:o}))}(t);return function(e){const n=(0,h.XI)(e,(e,n)=>e.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[n,t])}function m({value:e,tabValues:n}){return n.some(n=>n.value===e)}function f({queryString:e=!1,groupId:n}){const t=(0,a.W6)(),r=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,c.aZ)(r),(0,o.useCallback)(e=>{if(!r)return;const n=new URLSearchParams(t.location.search);n.set(r,e),t.replace({...t.location,search:n.toString()})},[r,t])]}function g(e){const{defaultValue:n,queryString:t=!1,groupId:r}=e,i=p(e),[s,a]=(0,o.useState)(()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!m({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const t=n.find(e=>e.default)??n[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:i})),[c,h]=f({queryString:t,groupId:r}),[u,g]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[t,r]=(0,d.Dv)(n);return[t,(0,o.useCallback)(e=>{n&&r.set(e)},[n,r])]}({groupId:r}),b=(()=>{const e=c??u;return m({value:e,tabValues:i})?e:null})();(0,l.A)(()=>{b&&a(b)},[b]);return{selectedValue:s,selectValue:(0,o.useCallback)(e=>{if(!m({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);a(e),h(e),g(e)},[h,g,i]),tabValues:i}}var b=t(2303);const y={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var x=t(4848);function j({className:e,block:n,selectedValue:t,selectValue:o,tabValues:i}){const a=[],{blockElementScrollPositionUntilNextRender:l}=(0,s.a_)(),c=e=>{const n=e.currentTarget,r=a.indexOf(n),s=i[r].value;s!==t&&(l(n),o(s))},h=e=>{let n=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const t=a.indexOf(e.currentTarget)+1;n=a[t]??a[0];break}case"ArrowLeft":{const t=a.indexOf(e.currentTarget)-1;n=a[t]??a[a.length-1];break}}n?.focus()};return(0,x.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":n},e),children:i.map(({value:e,label:n,attributes:o})=>(0,x.jsx)("li",{role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,ref:e=>{a.push(e)},onKeyDown:h,onClick:c,...o,className:(0,r.A)("tabs__item",y.tabItem,o?.className,{"tabs__item--active":t===e}),children:n??e},e))})}function v({lazy:e,children:n,selectedValue:t}){const i=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=i.find(e=>e.props.value===t);return e?(0,o.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,x.jsx)("div",{className:"margin-top--md",children:i.map((e,n)=>(0,o.cloneElement)(e,{key:n,hidden:e.props.value!==t}))})}function w(e){const n=g(e);return(0,x.jsxs)("div",{className:(0,r.A)(i.G.tabs.container,"tabs-container",y.tabList),children:[(0,x.jsx)(j,{...n,...e}),(0,x.jsx)(v,{...n,...e})]})}function k(e){const n=(0,b.A)();return(0,x.jsx)(w,{...e,children:u(e.children)},String(n))}},1812:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>d,default:()=>f,frontMatter:()=>h,metadata:()=>o,toc:()=>p});const o=JSON.parse('{"id":"control-locomotion","title":"5. Control Architectures for Locomotion","description":"The principles of bipedal walking, running, and maintaining balance.","source":"@site/docs/05-control-locomotion.mdx","sourceDirName":".","slug":"/control-locomotion","permalink":"/humanoid_robotics_textbook/control-locomotion","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"id":"control-locomotion","title":"5. Control Architectures for Locomotion","description":"The principles of bipedal walking, running, and maintaining balance.","sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"4. World Modeling & State Estimation","permalink":"/humanoid_robotics_textbook/world-modeling"},"next":{"title":"6. Principles of Robotic Manipulation","permalink":"/humanoid_robotics_textbook/manipulation"}}');var r=t(4848),i=t(8453),s=t(418),a=t(3457),l=t(1470),c=t(9365);const h={id:"control-locomotion",title:"5. Control Architectures for Locomotion",description:"The principles of bipedal walking, running, and maintaining balance.",sidebar_position:5},d=void 0,u={},p=[{value:"The Elegance and Terror of Two Legs",id:"the-elegance-and-terror-of-two-legs",level:2},{value:"The Center of Mass and the Support Polygon",id:"the-center-of-mass-and-the-support-polygon",level:3},{value:"The Classic Approach: Zero Moment Point (ZMP)",id:"the-classic-approach-zero-moment-point-zmp",level:3},{value:"The Modern Approach: Whole-Body Control (WBC)",id:"the-modern-approach-whole-body-control-wbc",level:3},{value:"Code Example: ZMP Stability Check",id:"code-example-zmp-stability-check",level:3}];function m(e){const n={code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"the-elegance-and-terror-of-two-legs",children:"The Elegance and Terror of Two Legs"}),"\n",(0,r.jsxs)(n.p,{children:["Walking is an act of continuously falling and catching yourself. For humans, this is second nature. For a robot, it is a monumental control challenge. Unlike a four-legged animal or a wheeled robot, a bipedal humanoid is ",(0,r.jsx)(n.strong,{children:"dynamically stable"}),". It cannot simply stand still without active control; it must constantly make minute adjustments to its posture to avoid tipping over."]}),"\n",(0,r.jsx)(n.p,{children:'This chapter dives into the control strategies that enable a robot to manage this "controlled fall" we call walking.'}),"\n",(0,r.jsx)(n.h3,{id:"the-center-of-mass-and-the-support-polygon",children:"The Center of Mass and the Support Polygon"}),"\n",(0,r.jsx)(n.p,{children:"To understand bipedal stability, we must first understand two key concepts:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Center of Mass (CoM):"})," The single point representing the average location of the total mass of the robot. You can think of it as the robot's balance point."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Support Polygon:"})," The area on the ground defined by the robot's contact points. When one foot is on the ground, it's the sole of that foot. When both feet are on the ground, it's the convex area encompassing both feet."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"For a robot to be statically stable (like a table), the vertical projection of its CoM must be inside the support polygon. But for walking, a dynamic process, we need a more sophisticated concept."}),"\n",(0,r.jsx)(s.A,{chart:"\ngraph TD\n  subgraph Robot Stance\n      CoM(Center of Mass);\n  end\n  subgraph Ground\n      direction LR\n      A(Left Foot)---B(Right Foot);\n      subgraph Support Polygon\n          direction TB\n          C(Center of Pressure / ZMP);\n      end\n  end\n  CoM -- Projects Down Into --\x3e C;\n  style CoM fill:#f9f9f9,stroke:#333,stroke-width:2px;\n  style C fill:#bde0fe,stroke:#333,stroke-width:2px;\n"}),"\n",(0,r.jsx)(n.h3,{id:"the-classic-approach-zero-moment-point-zmp",children:"The Classic Approach: Zero Moment Point (ZMP)"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"Zero Moment Point (ZMP)"})," is the foundational concept behind most classic humanoid walking controllers (like those used in Honda's ASIMO)."]}),"\n",(0,r.jsx)(n.p,{children:'The ZMP is the point on the ground where the net moment from inertial and gravitational forces is zero. In simpler terms, it\'s the point where the "tipping over" forces are perfectly balanced.'}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"The ZMP Stability Criterion:"})," For the robot to remain dynamically stable, the ZMP ",(0,r.jsx)(n.em,{children:"must"})," remain inside the support polygon at all times."]}),"\n",(0,r.jsx)(n.p,{children:"A ZMP-based controller works as follows:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Plan a ZMP Trajectory:"})," First, the controller plans a safe path for the ZMP to travel. This path typically moves smoothly from the center of one foot to the center of the other."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Plan a CoM Trajectory:"})," Based on the desired ZMP trajectory, the controller then calculates the corresponding trajectory for the robot's Center of Mass required to produce that ZMP path."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Calculate Joint Angles:"})," Finally, using inverse kinematics, the controller calculates the specific joint angles for the legs and torso that will move the CoM along its planned trajectory."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This method is robust and effective, especially for walking on flat surfaces, but it can be rigid and struggles to react to unexpected disturbances."}),"\n",(0,r.jsx)(n.h3,{id:"the-modern-approach-whole-body-control-wbc",children:"The Modern Approach: Whole-Body Control (WBC)"}),"\n",(0,r.jsxs)(n.p,{children:["While ZMP is focused on a single point, ",(0,r.jsx)(n.strong,{children:"Whole-Body Control (WBC)"})," is a more holistic and powerful paradigm. It treats the entire robot as a single, complex, and interconnected system."]}),"\n",(0,r.jsxs)(n.p,{children:["Instead of pre-calculating trajectories, WBC formulates the control problem as a real-time optimization. It defines a set of ",(0,r.jsx)(n.strong,{children:"tasks"})," and ",(0,r.jsx)(n.strong,{children:"constraints"}),", which are then solved simultaneously."]}),"\n",(0,r.jsx)(n.p,{children:"A typical set of tasks and constraints might look like this:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Highest Priority (Constraint):"})," Maintain physical contact with the ground without slipping."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"High Priority (Task):"})," Keep the torso perfectly upright."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Medium Priority (Task):"})," Move the swing foot to its next target location."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Low Priority (Task):"})," Move the hands to a resting position."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Universal Constraint:"})," Do not exceed joint angle or torque limits."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["An optimizer, typically a ",(0,r.jsx)(n.strong,{children:"Quadratic Programming (QP)"})," solver, runs hundreds of times per second. In each cycle, it finds the set of joint torques and accelerations that best satisfies this prioritized list of tasks without violating any constraints."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Advantages of WBC:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reactivity:"}),' Because it\'s a real-time optimization, WBC can react instantly to disturbances. If the robot is pushed, the "keep torso upright" task will immediately command the joints to counteract the force.']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Flexibility:"})," It can seamlessly blend tasks, like walking, waving, and tracking an object with its head, all within the same control framework."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Dynamicism:"})," WBC is naturally suited for highly dynamic motions like running, jumping, and acrobatics, where simple ZMP planning is insufficient."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"code-example-zmp-stability-check",children:"Code Example: ZMP Stability Check"}),"\n",(0,r.jsx)(n.p,{children:"A full locomotion controller is incredibly complex, but we can easily write the logic for the core ZMP stability criterion. This function checks if a given ZMP coordinate lies within the support polygon defined by the robot's feet."}),"\n",(0,r.jsx)(l.A,{children:(0,r.jsx)(c.A,{value:"python",label:"Python",children:(0,r.jsx)(a.A,{language:"python",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import numpy as np\n\ndef is_zmp_stable(zmp_pos, support_polygon):\n    """\n    Checks if the Zero Moment Point (ZMP) is inside the support polygon.\n\n    This uses the ray casting algorithm to determine if a point is inside a polygon.\n    \n    Args:\n        zmp_pos (np.array): A 2D array [x, y] for the ZMP coordinate.\n        support_polygon (list of tuples): A list of (x, y) vertices defining the\n                                           foot/feet contact area, in order.\n    \n    Returns:\n        bool: True if the ZMP is stable (inside the polygon), False otherwise.\n    """\n    x, y = zmp_pos\n    n = len(support_polygon)\n    inside = False\n\n    p1x, p1y = support_polygon[0]\n    for i in range(n + 1):\n        p2x, p2y = support_polygon[i % n]\n        if y > min(p1y, p2y):\n            if y <= max(p1y, p2y):\n                if x <= max(p1x, p2x):\n                    if p1y != p2y:\n                        xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x\n                    if p1x == p2x or x <= xinters:\n                        inside = not inside\n        p1x, p1y = p2x, p2y\n\n    return inside\n\n# --- Simulation ---\n# Define a support polygon for two feet on the ground\n# A rectangle from (-0.1, -0.1) to (0.1, 0.3)\nfoot_polygon = [\n    (-0.1, -0.1),  # Back-left corner\n    ( 0.1, -0.1),  # Back-right corner\n    ( 0.1,  0.3),  # Front-right corner\n    (-0.1,  0.3)   # Front-left corner\n]\n\n# Case 1: ZMP is safely inside the support polygon\nstable_zmp = np.array([0.0, 0.1])\nprint(f"Checking stable ZMP at {stable_zmp}...")\nprint(f"Result: {\'Stable\' if is_zmp_stable(stable_zmp, foot_polygon) else \'Unstable\'}\\n`)\n\n# Case 2: ZMP is outside the support polygon\nunstable_zmp = np.array([0.2, 0.1])\nprint(f"Checking unstable ZMP at {unstable_zmp}...")\nprint(f"Result: {\'Stable\' if is_zmp_stable(unstable_zmp, foot_polygon) else \'Unstable\'}")\n'})})})})})]})}function f(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(m,{...e})}):m(e)}},9365:(e,n,t)=>{t.d(n,{A:()=>s});t(6540);var o=t(4164);const r={tabItem:"tabItem_Ymn6"};var i=t(4848);function s({children:e,hidden:n,className:t}){return(0,i.jsx)("div",{role:"tabpanel",className:(0,o.A)(r.tabItem,t),hidden:n,children:e})}}}]);