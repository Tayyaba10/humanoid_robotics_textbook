"use strict";(globalThis.webpackChunkhumanoid_robotics_textbook=globalThis.webpackChunkhumanoid_robotics_textbook||[]).push([[568],{1470:(e,n,t)=>{t.d(n,{A:()=>k});var i=t(6540),a=t(4164),o=t(7559),r=t(3104),s=t(6347),l=t(205),d=t(7485),c=t(1682),u=t(679);function h(e){return i.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,i.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function m(e){const{values:n,children:t}=e;return(0,i.useMemo)(()=>{const e=n??function(e){return h(e).map(({props:{value:e,label:n,attributes:t,default:i}})=>({value:e,label:n,attributes:t,default:i}))}(t);return function(e){const n=(0,c.XI)(e,(e,n)=>e.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[n,t])}function p({value:e,tabValues:n}){return n.some(n=>n.value===e)}function f({queryString:e=!1,groupId:n}){const t=(0,s.W6)(),a=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,d.aZ)(a),(0,i.useCallback)(e=>{if(!a)return;const n=new URLSearchParams(t.location.search);n.set(a,e),t.replace({...t.location,search:n.toString()})},[a,t])]}function g(e){const{defaultValue:n,queryString:t=!1,groupId:a}=e,o=m(e),[r,s]=(0,i.useState)(()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!p({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const t=n.find(e=>e.default)??n[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:o})),[d,c]=f({queryString:t,groupId:a}),[h,g]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[t,a]=(0,u.Dv)(n);return[t,(0,i.useCallback)(e=>{n&&a.set(e)},[n,a])]}({groupId:a}),b=(()=>{const e=d??h;return p({value:e,tabValues:o})?e:null})();(0,l.A)(()=>{b&&s(b)},[b]);return{selectedValue:r,selectValue:(0,i.useCallback)(e=>{if(!p({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);s(e),c(e),g(e)},[c,g,o]),tabValues:o}}var b=t(2303);const y={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var x=t(4848);function v({className:e,block:n,selectedValue:t,selectValue:i,tabValues:o}){const s=[],{blockElementScrollPositionUntilNextRender:l}=(0,r.a_)(),d=e=>{const n=e.currentTarget,a=s.indexOf(n),r=o[a].value;r!==t&&(l(n),i(r))},c=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const t=s.indexOf(e.currentTarget)+1;n=s[t]??s[0];break}case"ArrowLeft":{const t=s.indexOf(e.currentTarget)-1;n=s[t]??s[s.length-1];break}}n?.focus()};return(0,x.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.A)("tabs",{"tabs--block":n},e),children:o.map(({value:e,label:n,attributes:i})=>(0,x.jsx)("li",{role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,ref:e=>{s.push(e)},onKeyDown:c,onClick:d,...i,className:(0,a.A)("tabs__item",y.tabItem,i?.className,{"tabs__item--active":t===e}),children:n??e},e))})}function j({lazy:e,children:n,selectedValue:t}){const o=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=o.find(e=>e.props.value===t);return e?(0,i.cloneElement)(e,{className:(0,a.A)("margin-top--md",e.props.className)}):null}return(0,x.jsx)("div",{className:"margin-top--md",children:o.map((e,n)=>(0,i.cloneElement)(e,{key:n,hidden:e.props.value!==t}))})}function w(e){const n=g(e);return(0,x.jsxs)("div",{className:(0,a.A)(o.G.tabs.container,"tabs-container",y.tabList),children:[(0,x.jsx)(v,{...n,...e}),(0,x.jsx)(j,{...n,...e})]})}function k(e){const n=(0,b.A)();return(0,x.jsx)(w,{...e,children:h(e.children)},String(n))}},9365:(e,n,t)=>{t.d(n,{A:()=>r});t(6540);var i=t(4164);const a={tabItem:"tabItem_Ymn6"};var o=t(4848);function r({children:e,hidden:n,className:t}){return(0,o.jsx)("div",{role:"tabpanel",className:(0,i.A)(a.tabItem,t),hidden:n,children:e})}},9541:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>u,default:()=>f,frontMatter:()=>c,metadata:()=>i,toc:()=>m});const i=JSON.parse('{"id":"simulation-sim-to-real","title":"10. Simulation & Sim-to-Real","description":"Using simulators for robot development and bridging the reality gap.","source":"@site/docs/10-simulation-sim-to-real.mdx","sourceDirName":".","slug":"/simulation-sim-to-real","permalink":"/humanoid_robotics_textbook/docs/simulation-sim-to-real","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"id":"simulation-sim-to-real","title":"10. Simulation & Sim-to-Real","description":"Using simulators for robot development and bridging the reality gap.","sidebar_position":10},"sidebar":"tutorialSidebar","previous":{"title":"9. Foundation Models in Robotics","permalink":"/humanoid_robotics_textbook/docs/foundation-models"},"next":{"title":"11. Hardware-Software Co-Design","permalink":"/humanoid_robotics_textbook/docs/hardware-software-codesign"}}');var a=t(4848),o=t(8453),r=t(418),s=t(3457),l=t(1470),d=t(9365);const c={id:"simulation-sim-to-real",title:"10. Simulation & Sim-to-Real",description:"Using simulators for robot development and bridging the reality gap.",sidebar_position:10},u=void 0,h={},m=[{value:"The Robot&#39;s Playground: The Role of Simulation",id:"the-robots-playground-the-role-of-simulation",level:2},{value:"Why Simulate?",id:"why-simulate",level:3},{value:"The &quot;Reality Gap&quot;",id:"the-reality-gap",level:3},{value:"Bridging the Gap: Sim-to-Real Techniques",id:"bridging-the-gap-sim-to-real-techniques",level:3},{value:"1. System Identification: Make the Sim More Real",id:"1-system-identification-make-the-sim-more-real",level:4},{value:"2. Domain Randomization: Make the Policy More Robust",id:"2-domain-randomization-make-the-policy-more-robust",level:4},{value:"Code Example: Logic of Domain Randomization",id:"code-example-logic-of-domain-randomization",level:3}];function p(e){const n={code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"the-robots-playground-the-role-of-simulation",children:"The Robot's Playground: The Role of Simulation"}),"\n",(0,a.jsxs)(n.p,{children:["Developing algorithms on a million-dollar humanoid prototype is a high-stakes game. A single bug in a control loop could lead to a catastrophic fall, causing expensive damage and weeks of downtime. For this reason, modern robotics development, especially for learning-based approaches, is deeply reliant on ",(0,a.jsx)(n.strong,{children:"simulation"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"A simulator is a virtual environment where a digital twin of the robot can be tested, trained, and validated before its code ever touches real hardware."}),"\n",(0,a.jsx)(n.h3,{id:"why-simulate",children:"Why Simulate?"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Safety:"})," A robot can fall over a million times in simulation with zero cost. This freedom to fail is essential for learning algorithms that operate by trial and error."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Speed & Scale:"})," Simulations can be run much faster than real-time. A day of real-world experience can be compressed into minutes. Furthermore, thousands of simulations can be run in parallel on the cloud, enabling the massive scale required by modern Reinforcement Learning."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Cost:"})," Running a simulation is vastly cheaper than operating, maintaining, and repairing a complex physical prototype."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"A good robotics simulator must have a few key components:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Physics Engine:"})," The core of the simulator, responsible for accurately modeling forces, gravity, contact, and friction. Popular engines include MuJoCo, PhysX, and Bullet."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Rendering Engine:"})," To train vision-based policies, the simulator must produce realistic images. This is often handled by game engines like Unity or Unreal Engine."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Robot Model:"})," A high-fidelity model of the robot itself, typically in a format like URDF (Unified Robot Description Format), which defines the robot's physical properties (mass, inertia of each link) and sensor characteristics."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"the-reality-gap",children:'The "Reality Gap"'}),"\n",(0,a.jsxs)(n.p,{children:["As powerful as simulation is, it's never perfect. There will always be subtle (and sometimes not-so-subtle) differences between the simulated world and the real world. This discrepancy is known as the ",(0,a.jsx)(n.strong,{children:"sim-to-real gap"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Sources of the reality gap include:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Physics Mismatch:"})," Inaccurate modeling of friction, contact forces, or an object's mass."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Actuator Dynamics:"})," Unmodeled delays in motor responses or variations in power delivery."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Sensor Noise:"})," A real camera has motion blur and noise patterns that a simple virtual camera lacks."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Visual Differences:"})," Textures, lighting, and reflections in the real world are far more complex than in most simulations."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:'A policy trained exclusively in a "perfect" simulation will likely fail when deployed on a real robot because it is not robust to these unmodeled real-world effects. The entire field of sim-to-real is dedicated to bridging this gap.'}),"\n",(0,a.jsx)(n.h3,{id:"bridging-the-gap-sim-to-real-techniques",children:"Bridging the Gap: Sim-to-Real Techniques"}),"\n",(0,a.jsx)(n.p,{children:"The development cycle is not just about building in simulation; it's about transferring that work to reality."}),"\n",(0,a.jsx)(r.A,{chart:"\ngraph TD\n  A(Develop in Sim) --\x3e B(Train Policy);\n  B --\x3e C{Bridge Reality Gap};\n  C --\x3e D(Deploy on Real Robot);\n  D --\x3e E(Analyze Performance);\n  E --\x3e A;\n"}),"\n",(0,a.jsx)(n.p,{children:"Two primary strategies are used to bridge the gap:"}),"\n",(0,a.jsx)(n.h4,{id:"1-system-identification-make-the-sim-more-real",children:"1. System Identification: Make the Sim More Real"}),"\n",(0,a.jsx)(n.p,{children:"System Identification is the process of measuring the properties of the real world and updating the simulation to match. Engineers will perform experiments to measure the precise friction coefficients of the robot's feet, the mass of each link, and the response time of the motors. This data is then fed back into the simulator to create a higher-fidelity model. The goal is to shrink the reality gap by making the simulation a more accurate twin of reality."}),"\n",(0,a.jsx)(n.h4,{id:"2-domain-randomization-make-the-policy-more-robust",children:"2. Domain Randomization: Make the Policy More Robust"}),"\n",(0,a.jsx)(n.p,{children:"Domain Randomization takes the opposite approach. Instead of trying to create one perfect simulation, it creates thousands of slightly different ones. During training, the policy is exposed to a wide range of variations in the simulation's parameters."}),"\n",(0,a.jsx)(n.p,{children:"For every training episode, the system might randomize:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"The robot's mass and the friction of its joints."}),"\n",(0,a.jsx)(n.li,{children:"The lighting conditions and textures in the scene."}),"\n",(0,a.jsx)(n.li,{children:"The position and noise of the virtual camera."}),"\n",(0,a.jsx)(n.li,{children:"The latency of the motors."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:'By learning to succeed across this wide distribution of simulated worlds, the policy becomes robust to variation. It learns to ignore irrelevant visual textures and adapt to different physical properties. The hope is that the real world will simply feel like "just another variation" it has already seen during training.'}),"\n",(0,a.jsx)(n.h3,{id:"code-example-logic-of-domain-randomization",children:"Code Example: Logic of Domain Randomization"}),"\n",(0,a.jsx)(n.p,{children:"Let's write a conceptual script for a training loop that uses domain randomization. Notice how the simulation's parameters are changed before each run."}),"\n",(0,a.jsx)(l.A,{children:(0,a.jsx)(d.A,{value:"python",label:"Python",children:(0,a.jsx)(s.A,{language:"python",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'import numpy as np\n\nclass SimulatedRobot:\n    def __init__(self):\n        # Default physics parameters\n        self.mass = 80.0  # kg\n        self.friction = 0.7 # coefficient of friction\n        print(f"Robot initialized with mass: {self.mass}, friction: {self.friction}")\n\n    def randomize_domain(self):\n        """Randomizes physics parameters to create diverse training environments."""\n        self.mass = np.random.uniform(50.0, 100.0) # Randomize mass\n        self.friction = np.random.uniform(0.5, 1.0) # Randomize friction\n        # Further randomizations for textures, lighting, sensor noise etc.\n        print(f"Domain randomized. New mass: {self.mass:.2f}, new friction: {self.friction:.2f}")\n\n    def simulate_step(self, action):\n        """\n        Simulates one step of the robot\'s interaction with the environment.\n        (Simplified for conceptual example)\n        """\n        # Imagine complex physics calculations here...\n        # Returns next_state (e.g., sensor readings) and reward\n        next_state = np.random.rand(10)\n        reward = np.random.rand()\n        return next_state, reward\n\n# --- Simulation Training Loop with Domain Randomization ---\nrobot = SimulatedRobot()\n\nfor episode in range(10): # Run 10 training episodes\n    print(f"\\n--- EPISODE {episode + 1} ---")\n    robot.randomize_domain() # Randomize environment for each episode\n\n    # Reset robot to initial state in the randomized environment\n    current_state = np.zeros(10) \n\n    for step in range(100): # Simulate 100 steps per episode\n        action = np.random.rand(4) # Random actions for illustration\n        next_state, reward = robot.simulate_step(action)\n        current_state = next_state\n        # In a real RL setup, the agent would learn from (current_state, action, reward, next_state)\n'})})})})})]})}function f(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}}}]);